# Advent of Code 2022

Again I tried to find out how far I can make it in [Advent of Code](https://adventofcode.com/2022/). Results for previous editions:
* 2018: 9 days
* 2019: 13 days
* [2020](https://github.com/Leftfish/Advent-of-Code-2020): 25 days for the first time!
* [2021](https://github.com/Leftfish/Advent-of-Code-2021): 25 days for the second time!

During the first couple of days, I implemented the solution in Python first and then tried to do the same in Java (just to see if I can still write anything remotely resembling it). Then, I had to rely on hints from the awesome AoC community with days 11 (part 2), 16, 21 (part 2) and 24.

As of 25.12.2022 I had 44 stars which is more/less on par with previous years. Still three puzzles (1.5 'days') to go.

Things I **L**earned, **R**evised or **I**mproved at in 2022:

* [Day 1 Python](01/d01.py) | [Day 1 Java](01/Day01.java): debugging stupid mistakes (**R**) and not using list comprehensions to improve readability (**R**) in Python; reading a text file with BufferedReader (**L**) and sorting with Collections.sort (**L**) in Java
* [Day 2 Python](02/d02.py) | [Day 2 Java](02/Day02.java): using Enum and IntEnum in Python (**L**); using HashMaps in Java (**R**)
* [Day 3 Python](03/d03.py) | [Day 3 Java](03/Day03.java): set operations in Python (**R**); using streams in Java (**L**)
* [Day 4 Python](04/d04.py) | [Day 4 Java](04/Day04.java): regular expressions (**R**) in Python and in Java (**L**)
* [Day 5 Python](05/d05.py): using lists as stacks (**R**)
* [Day 6 Python](06/d06.py): set operations (**R**)
* [Day 7 Python](07/d07.py): defaultdict (**R**) and that sometimes even if DFS looks like a go-to solution, it is not necessary it
* [Day 8 Python](08/d08.py): functools.reduce (**R**)
* [Day 9 Python](09/d09.py): Manhattan distance (**R**)
* [Day 10 Python](10/d10.py): some very basic OOP principles (**R**)
* [Day 11 Python](11/d11.py): modular arithmetic (**I**)
* [Day 12 Python](12/d12.py): unweighted graphs (**R**) and BFS (**R**)
* [Day 13 Python](13/d13.py): recursive functions (**R**), writing custom comparators (**I**) and using functools.cmp_to_key (**L**)
* [Day 14 Python](14/d14.py): using sets to store positions on 2D grid (**R**)
* [Day 15 Python](15/d15.py): Manhattan distance (**R**)
* [Day 16 Python](16/d16.py): iterative BFS (**R**) and iterative DFS (**I**), using frozenset as key (**R**)
* [Day 17 Python](17/d17.py): using Enum and itertools.cycle in Python (**I**), detecting collisions on 2D grid (**L**) and using Python as a hand calculator for part 2 ;)
* [Day 18 Python](18/d18.py): set operations (**R**) and BFS in 3D space as a flood-fill function (**L**)
* Day 19: TO DO
* [Day 20 Python](20/d20.py): modular arithmetic (**I**) and circular doubly-linked lists (**R**)
* [Day 21 Python](21/d21.py): recursion (**R**) and binary search for part 2 (**R**)
* [Day 22 Python part 1](22/d22.py): traversing 2D grids (**R**), part 2 TO DO
* [Day 23 Python](23/d23.py): set operations (**R**) and enums (**R**)
* [Day 24 Python](24/d24.py): finding the shortest path using A* (**I**) with heapq (**R**) and using modulo to calculate positions of repeating patterns (**I**)
* [Day 25 Python](25/d25.py): balanced signed-digit representations of integers (**L**)
